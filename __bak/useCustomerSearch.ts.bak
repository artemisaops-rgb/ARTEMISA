// src/hooks/useCustomerSearch.ts
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  collection,
  getDocs,
  getFirestore,
  limit,
  orderBy,
  query as fsQuery,
  startAfter,
  where,
  DocumentData,
  QueryDocumentSnapshot,
} from "firebase/firestore";
import { db as defaultDb } from "@/services/firebase";

export type CustomerLite = {
  id: string;            // uid
  orgId: string;
  displayName?: string | null;
  email?: string | null;
  photoURL?: string | null;
  points?: number;
  stampsProgress?: number;
  totalStamps?: number;
  freeCredits?: number;
};

export type UseCustomerSearch = {
  results: CustomerLite[];
  loading: boolean;
  error?: string;
  hasMore: boolean;
  fetchMore: () => Promise<void>;
  reset: () => void;
};

function useDebounced<T>(value: T, ms = 300) {
  const [v, setV] = useState(value);
  useEffect(() => {
    const id = setTimeout(() => setV(value), ms);
    return () => clearTimeout(id);
  }, [value, ms]);
  return v;
}

/**
 * BÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Âºsqueda simple por clientes del orgId. Consulta por updatedAt (paginable)
 * y filtra por texto en el cliente (nombre/email/id) en el cliente.
 */
export function useCustomerSearch(
  orgId: string,
  q: string,
  pageSize = 12,
  _db = defaultDb ?? getFirestore()
): UseCustomerSearch {
  const [results, setResults] = useState<CustomerLite[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string>();
  const [hasMore, setHasMore] = useState(false);
  const lastDocRef = useRef<QueryDocumentSnapshot<DocumentData> | null>(null);
  const debounced = useDebounced(q.trim().toLowerCase(), 250);

  const baseQuery = useMemo(() => {
    return fsQuery(
      collection(_db, "customers"),
      where("orgId", "==", orgId),
      orderBy("updatedAt", "desc"),
      limit(pageSize)
    );
  }, [_db, orgId, pageSize]);

  const run = useCallback(
    async (append = false) => {
      setLoading(true);
      setError(undefined);
      try {
        const q = append && lastDocRef.current
          ? fsQuery(baseQuery, startAfter(lastDocRef.current))
          : baseQuery;

        const snap = await getDocs(q);
        const docs = snap.docs;
        if (docs.length) lastDocRef.current = docs[docs.length - 1];

        const mapped = docs.map((d) => {
          const v: any = d.data();
          const c: CustomerLite = {
            id: d.id,
            orgId: v.orgId,
            displayName: v.displayName ?? null,
            email: v.email ?? null,
            photoURL: v.photoURL ?? null,
            points: v.points ?? 0,
            stampsProgress: v.stampsProgress ?? 0,
            totalStamps: v.totalStamps ?? 0,
            freeCredits: v.freeCredits ?? 0,
          };
          return c;
        });

        setResults((prev) => {
          const next = append ? prev.concat(mapped) : mapped;
          // filtro por texto en cliente
          if (!debounced) return next;
          const t = debounced;
          return next.filter(
            (c) =>
              (c.displayName || "").toLowerCase().includes(t) ||
              (c.email || "").toLowerCase().includes(t) ||
              c.id.toLowerCase().includes(t)
          );
        });

        setHasMore(docs.length === pageSize);
      } catch (e: any) {
        setError(e?.message || "Error al buscar clientes");
      } finally {
        setLoading(false);
      }
    },
    [baseQuery, debounced]
  );

  useEffect(() => {
    lastDocRef.current = null;
    setResults([]);
    setHasMore(false);
    setError(undefined);
    if (orgId) run(false);
  }, [orgId, debounced, run]);

  const fetchMore = useCallback(async () => {
    if (!hasMore || loading) return;
    await run(true);
  }, [hasMore, loading, run]);

  const reset = useCallback(() => {
    lastDocRef.current = null;
    setResults([]);
    setHasMore(false);
    setError(undefined);
  }, []);

  return { results, loading, error, hasMore, fetchMore, reset };
}
